# ---------------  abhinav raj 2311006 ---------------
############################    question-1  #############################



import matplotlib.pyplot as plt
from mylib import *
import numpy as np

# LCG parameters
a = 1103515245
c = 12345
m = 32768

x_val = []
y_val = []
limit = 20
L1 = []
L2 = []
while limit <= 10000:
    l1 = lcg().lcg_gen(limit, 10, a, c, m)
    l2 = lcg().lcg_gen(limit, 20, a, c, m)

    L1 = [n / m for n in l1]
    L2 = [n / m for n in l2]

    count = 0
    for i in range(limit):
        px = L1[i]
        py = L2[i]
        if (px**2)/4 + (py**2)/1 <= 1:
            count += 1

    area =  count / limit
    x_val.append(limit)
    y_val.append(area)

    limit += 1

ellipse_area_estimates = [area * 8 for area in y_val] 
plt.scatter(x_val, ellipse_area_estimates)
plt.xlabel("number of iterations")
plt.ylabel("Estimated area of ellipse")
plt.title("Iterations vs Estimated Area of Ellipse")
plt.show()
print("Average estimated area of ellipse is:", np.mean(ellipse_area_estimates))



#######################-------output-------######################

# Average estimated area of ellipse is: 7.65378614491

##################################################################


# ------------------- question 2 ----------------------

import math 
from mylib import root
def fun(x):
    return  (x-5)*math.exp(x) + 5

def f1(x):
    return  math.exp(x) * (x - 4)

a=1
b=5
x0 = 3  

r = root().n_raphson(fun, f1, a, b, x0, iter=100, acc=1e-4)
print(r, "root using n_raphson method, iteration steps")
# --- Constants ---
h = 6.626e-34
c = 3e8
k = 1.381e-23

# --- Wien's constant ---
b_value = (h * c) / (k * r[0])
print(f"Wien's constant b = {b_value:.6e} m·K")

# ####################################################3
# ###########---------output----############################

[4.636194872165416e-07, 5] root using n_raphson method, iteration steps
Wien's constant b = 3.104683e+04 m·K 

##########################################################



#########################   question-2  #############################

from mylib import *

A = read_matrix().read_matrix1("t3.txt")

LU_A = LU_decom().LU_matrix(A) 
L, U = LU_decom().LU_matrix(A)
inverse_A = LU_decom().inverse_from_LU(L, U)

for row in inverse_A:
    print(row)

print("Inverse of A using LU decomposition (rounded to 3 decimal places):")
for row in inverse_A:
    print([round(val, 3) for val in row])

##########################-------output-------######################
Inverse of A using LU decomposition (rounded to 3 decimal places):
[7.785, 1.254, -3.563, -0.007, 0.0]
[0.111, 0.049, -0.143, -0.0, 0.0]
[-0.001, -0.001, -0.0, 0.0, -0.0]
[0.0, -0.0, -0.0, -0.0, 0.0]
[2.25, 3.619, -0.708, -0.005, 0.0]
########################################################




# -------------------------- question 4 ----------------------

from mylib import *

E = read_matrix().read_matrix1("mt1.txt")
F = read_matrix().read_matrix1("mt2.txt")

A_rearranged = diadominant().dia_dominant(E)

print("Solution with precision of order 6:")
solution = GaussSeidel().gauss_seidel_iter(A_rearranged, F)
for i, xi in enumerate(solution, 1):
    print(f"x{i} = {xi[0]:.6f}")


##########################----------------output----------------##########
# Solution with precision of order 6:
# x1 = 1.500000
# x2 = -0.500000
# x3 = 2.000000
# x4 = -2.500000
# x5 = 1.000000
# x6 = -1.000000

######################################################################
