# ---------------  abhinav raj 2311006 ---------------
############################    question-1  #############################



import matplotlib.pyplot as plt
from mylib import *
import numpy as np

# LCG parameters
a = 1103515245
c = 12345
m = 32768

x_val = []
y_val = []
limit = 20
L1 = []
L2 = []
while limit <= 10000:
    l1 = lcg().lcg_gen(limit, 10, a, c, m)
    l2 = lcg().lcg_gen(limit, 20, a, c, m)

    L1 = [n / m for n in l1]
    L2 = [n / m for n in l2]

    count = 0
    for i in range(limit):
        px = L1[i]
        py = L2[i]
        if (px**2)/4 + (py**2)/1 <= 1:
            count += 1

    area =  count / limit
    x_val.append(limit)
    y_val.append(area)

    limit += 1

ellipse_area_estimates = [area * 4 for area in y_val] 
plt.scatter(x_val, ellipse_area_estimates)
plt.xlabel("number of iterations")
plt.ylabel("Estimated area of ellipse")
plt.title("Iterations vs Estimated Area of Ellipse")
plt.show()
print("Average estimated area of ellipse is:", np.mean(ellipse_area_estimates))



#######################-------output-------######################

# Average estimated area of ellipse is: 3.8268930724564427

##################################################################


# ------------------- question 2 ----------------------

import math 
from mylib import root
def fun(x):
    return  (x-5)*math.exp(x) + 5

def f1(x):
    return  math.exp(x)*(x-5) + math.exp(x)


a = 1
b = 5
x0 = 3  

r = root().n_raphson(fun, f1, a, b, x0, iter=100, acc=1e-4)
print(r, "root using n_raphson method, iteration steps")

b_value = (6.626 * 10**-34) / (r[0]) * (1.381 * 10**-23)
print("value of b:", b_value)

# ####################################################3
# ###########---------output----############################

# [4.6361948721632476e-07, 5] root using n_raphson method, iteration steps
# value of b: 1.973710392317995e-50

##########################################################



#########################   question-2  #############################

from mylib import *

A = read_matrix().read_matrix1("t3.txt")

LU_A = LU_decom().LU_matrix(A) 
L, U = LU_decom().LU_matrix(A)
inverse_A = LU_decom().inverse_from_LU(L, U)

for row in inverse_A:
    print(row)

print("Inverse of A using LU decomposition (rounded to 3 decimal places):")
for row in inverse_A:
    print([round(val, 3) for val in row])

##########################-------output-------######################
# there is some error in my library in line self.forward and self.backward 
# otherwise it is giving output if we directly use function without putting in class 

# so .........
########################################################




# -------------------------- question 4 ----------------------

from mylib import *

E = read_matrix().read_matrix1("mt1.txt")
F = read_matrix().read_matrix1("mt2.txt")

A_rearranged = diadominant().dia_dominant(E)

print("Solution with precision of order 6:")
solution = GaussSeidel().gauss_seidel_iter(A_rearranged, F)
for i, xi in enumerate(solution, 1):
    print(f"x{i} = {xi[0]:.6f}")


##########################----------------output----------------##########
# Solution with precision of order 6:
# x1 = 1.500000
# x2 = -0.500000
# x3 = 2.000000
# x4 = -2.500000
# x5 = 1.000000
# x6 = -1.000000

######################################################################
