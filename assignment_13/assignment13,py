# ---------  abhinav raj 2311006 -----------
#########################  question-1 ###########################


import numpy as np
import matplotlib.pyplot as plt
import math
from mylib import *
import numpy as np



def f1(x,y):
    return y- x**2
def f2(x,y):
    return (x + y)**2

def f3(x):
    return x**2 + 2*x +2-2*math.exp(x)

def f4(x):
    return math.tan(x + math.pi/4) - x

# def plot_functions(f, a, b, num_points=100):
#     x_vals = np.linspace(a, b, num_points)
#     y_vals = [f(x) for x in x_vals]
#     plt.plot(x_vals, y_vals)
#     plt.axhline(0, color='black', linewidth=0.5, linestyle='--')
#     plt.axvline(0, color='black', linewidth=0.5, linestyle='--')
#     plt.title("Plot of the function")
#     plt.xlabel("x")
#     plt.ylabel("f(x)")
#     plt.show()


b1 = 2.0
def forward_euler(f, x0, y0, h):

    L_x = []
    L_y = []
    x = x0
    y = y0
    for i in range(20):
        y = y + h * f(x, y)
        x = x + h
        L_x.append(x)
        L_y.append(y)
    plt.plot(L_x, L_y, label="Forward Euler")
    return y




b2 = math.pi / 5.0

def predictor_corrector(f, x0, y0, h):

    
    L_x = []
    L_y = []
    x = x0
    y = y0
    for i in range(7):
        y_pred = y + h * f(x, y)
        x_new = x + h
        y = y + (h / 2) * (f(x, y) + f(x_new, y_pred))
        x = x_new
        L_x.append(x)
        L_y.append(y)
    plt.plot(L_x, L_y, label="Predictor-Corrector")
    return y


print("Forward Euler for f1: {:.9f}".format(forward_euler(f1, 0, 0, 0.1)))
print("Forward Euler for f2: {:.9f}".format(forward_euler(f2, 0, 1, 0.1)))
print("Predictor-Corrector for f1: {:.9f}".format(predictor_corrector(f1, 0, 0, 0.1)))
print("Predictor-Corrector for f2: {:.9f}".format(predictor_corrector(f2, 0, 1, 0.1)))

# plot_functions(f3, 0, 2)
# plot_functions(f4, 0, math.pi/5)

plt.xlabel("x")
plt.ylabel("y")
plt.legend()
plt.show()

# Corrected runs, comparisons with analytical solutions and plots

import matplotlib.pyplot as plt

# Problem 1: dy/dx = y - x^2, y(0)=0, analytic: y = x^2 + 2x + 2 - 2 e^x
x0 = 0.0
y0 = 0.0   # correct initial condition
h = 0.1
b1 = 2.0
n1 = int(math.ceil((b1 - x0) / h))
y_fe_1 = forward_euler(f1, x0, y0, h, n1)
y_pc_1 = predictor_corrector(f1, x0, y0, h, n1)
x_final_1 = x0 + n1 * h
y_true_1 = f3(x_final_1)

print("Problem 1 at x = {:.6f}".format(x_final_1))
print("  Forward Euler:           {:.9f}, error = {:.9e}".format(y_fe_1, abs(y_fe_1 - y_true_1)))
print("  Predictor-Corrector:     {:.9f}, error = {:.9e}".format(y_pc_1, abs(y_pc_1 - y_true_1)))
print("  Analytic solution:       {:.9f}".format(y_true_1))

# Plot analytic vs numerical (new figure)
x_plot_1 = np.linspace(x0, x_final_1, 300)
y_plot_true_1 = [f3(xx) for xx in x_plot_1]

plt.figure()
plt.plot(x_plot_1, y_plot_true_1, 'k-', label='Analytic (problem 1)')
# Note: forward_euler and predictor_corrector already plotted their numerical curves when called.
plt.xlabel('x')
plt.ylabel('y')
plt.title('Problem 1: dy/dx = y - x^2')
plt.legend()
plt.grid(True)
plt.show()

# Problem 2: dy/dx = (x + y)^2, y(0)=1, analytic: y = tan(x + pi/4) - x
x0 = 0.0
y0 = 1.0   # correct initial condition
h = 0.1
b2 = math.pi / 5.0
n2 = int(math.ceil((b2 - x0) / h))
y_fe_2 = forward_euler(f2, x0, y0, h, n2)
y_pc_2 = predictor_corrector(f2, x0, y0, h, n2)
x_final_2 = x0 + n2 * h
y_true_2 = f4(x_final_2)

print("Problem 2 at x = {:.6f}".format(x_final_2))
print("  Forward Euler:           {:.9f}, error = {:.9e}".format(y_fe_2, abs(y_fe_2 - y_true_2)))
print("  Predictor-Corrector:     {:.9f}, error = {:.9e}".format(y_pc_2, abs(y_pc_2 - y_true_2)))
print("  Analytic solution:       {:.9f}".format(y_true_2))

# Plot analytic vs numerical (new figure)
x_plot_2 = np.linspace(x0, x_final_2, 300)
y_plot_true_2 = [f4(xx) for xx in x_plot_2]
